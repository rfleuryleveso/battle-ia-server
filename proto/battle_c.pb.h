// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: battle_c.proto
// Protobuf C++ Version: 5.29.2

#ifndef battle_5fc_2eproto_2epb_2eh
#define battle_5fc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_battle_5fc_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_battle_5fc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_battle_5fc_2eproto;
namespace battle_c {
class ClientInit;
struct ClientInitDefaultTypeInternal;
extern ClientInitDefaultTypeInternal _ClientInit_default_instance_;
class ClientServerMessage;
struct ClientServerMessageDefaultTypeInternal;
extern ClientServerMessageDefaultTypeInternal _ClientServerMessage_default_instance_;
class PlayerData;
struct PlayerDataDefaultTypeInternal;
extern PlayerDataDefaultTypeInternal _PlayerData_default_instance_;
class PlayersSighted;
struct PlayersSightedDefaultTypeInternal;
extern PlayersSightedDefaultTypeInternal _PlayersSighted_default_instance_;
class RadarResult;
struct RadarResultDefaultTypeInternal;
extern RadarResultDefaultTypeInternal _RadarResult_default_instance_;
class RadarReturn;
struct RadarReturnDefaultTypeInternal;
extern RadarReturnDefaultTypeInternal _RadarReturn_default_instance_;
class ServerClientMessage;
struct ServerClientMessageDefaultTypeInternal;
extern ServerClientMessageDefaultTypeInternal _ServerClientMessage_default_instance_;
class Shoot;
struct ShootDefaultTypeInternal;
extern ShootDefaultTypeInternal _Shoot_default_instance_;
class ShootResult;
struct ShootResultDefaultTypeInternal;
extern ShootResultDefaultTypeInternal _ShootResult_default_instance_;
class Vector2;
struct Vector2DefaultTypeInternal;
extern Vector2DefaultTypeInternal _Vector2_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class WorldOptions;
struct WorldOptionsDefaultTypeInternal;
extern WorldOptionsDefaultTypeInternal _WorldOptions_default_instance_;
}  // namespace battle_c
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace battle_c {
enum RadarReturnType : int {
  PLAYER = 0,
  WALL = 1,
  BOOST = 2,
  RadarReturnType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RadarReturnType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RadarReturnType_IsValid(int value);
extern const uint32_t RadarReturnType_internal_data_[];
constexpr RadarReturnType RadarReturnType_MIN = static_cast<RadarReturnType>(0);
constexpr RadarReturnType RadarReturnType_MAX = static_cast<RadarReturnType>(2);
constexpr int RadarReturnType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
RadarReturnType_descriptor();
template <typename T>
const std::string& RadarReturnType_Name(T value) {
  static_assert(std::is_same<T, RadarReturnType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RadarReturnType_Name().");
  return RadarReturnType_Name(static_cast<RadarReturnType>(value));
}
template <>
inline const std::string& RadarReturnType_Name(RadarReturnType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RadarReturnType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RadarReturnType_Parse(absl::string_view name, RadarReturnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RadarReturnType>(
      RadarReturnType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class WorldOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:battle_c.WorldOptions) */ {
 public:
  inline WorldOptions() : WorldOptions(nullptr) {}
  ~WorldOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WorldOptions* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WorldOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorldOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline WorldOptions(const WorldOptions& from) : WorldOptions(nullptr, from) {}
  inline WorldOptions(WorldOptions&& from) noexcept
      : WorldOptions(nullptr, std::move(from)) {}
  inline WorldOptions& operator=(const WorldOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldOptions& operator=(WorldOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldOptions* internal_default_instance() {
    return reinterpret_cast<const WorldOptions*>(
        &_WorldOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(WorldOptions& a, WorldOptions& b) { a.Swap(&b); }
  inline void Swap(WorldOptions* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldOptions* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WorldOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorldOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WorldOptions& from) { WorldOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WorldOptions* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "battle_c.WorldOptions"; }

 protected:
  explicit WorldOptions(::google::protobuf::Arena* arena);
  WorldOptions(::google::protobuf::Arena* arena, const WorldOptions& from);
  WorldOptions(::google::protobuf::Arena* arena, WorldOptions&& from) noexcept
      : WorldOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapXFieldNumber = 1,
    kMapYFieldNumber = 2,
    kGridResolutionFieldNumber = 4,
    kMaxPlayersFieldNumber = 5,
    kGridBasedFieldNumber = 3,
    kAutoShootAllowedFieldNumber = 6,
    kRadarEnabledFieldNumber = 7,
  };
  // int32 map_x = 1;
  void clear_map_x() ;
  ::int32_t map_x() const;
  void set_map_x(::int32_t value);

  private:
  ::int32_t _internal_map_x() const;
  void _internal_set_map_x(::int32_t value);

  public:
  // int32 map_y = 2;
  void clear_map_y() ;
  ::int32_t map_y() const;
  void set_map_y(::int32_t value);

  private:
  ::int32_t _internal_map_y() const;
  void _internal_set_map_y(::int32_t value);

  public:
  // float grid_resolution = 4;
  void clear_grid_resolution() ;
  float grid_resolution() const;
  void set_grid_resolution(float value);

  private:
  float _internal_grid_resolution() const;
  void _internal_set_grid_resolution(float value);

  public:
  // int32 max_players = 5;
  void clear_max_players() ;
  ::int32_t max_players() const;
  void set_max_players(::int32_t value);

  private:
  ::int32_t _internal_max_players() const;
  void _internal_set_max_players(::int32_t value);

  public:
  // bool grid_based = 3;
  void clear_grid_based() ;
  bool grid_based() const;
  void set_grid_based(bool value);

  private:
  bool _internal_grid_based() const;
  void _internal_set_grid_based(bool value);

  public:
  // bool auto_shoot_allowed = 6;
  void clear_auto_shoot_allowed() ;
  bool auto_shoot_allowed() const;
  void set_auto_shoot_allowed(bool value);

  private:
  bool _internal_auto_shoot_allowed() const;
  void _internal_set_auto_shoot_allowed(bool value);

  public:
  // bool radar_enabled = 7;
  void clear_radar_enabled() ;
  bool radar_enabled() const;
  void set_radar_enabled(bool value);

  private:
  bool _internal_radar_enabled() const;
  void _internal_set_radar_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:battle_c.WorldOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WorldOptions& from_msg);
    ::int32_t map_x_;
    ::int32_t map_y_;
    float grid_resolution_;
    ::int32_t max_players_;
    bool grid_based_;
    bool auto_shoot_allowed_;
    bool radar_enabled_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battle_5fc_2eproto;
};
// -------------------------------------------------------------------

class Vector3 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:battle_c.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vector3* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vector3));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vector3(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vector3(const Vector3& from) : Vector3(nullptr, from) {}
  inline Vector3(Vector3&& from) noexcept
      : Vector3(nullptr, std::move(from)) {}
  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
        &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Vector3& a, Vector3& b) { a.Swap(&b); }
  inline void Swap(Vector3* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vector3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vector3& from) { Vector3::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vector3* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "battle_c.Vector3"; }

 protected:
  explicit Vector3(::google::protobuf::Arena* arena);
  Vector3(::google::protobuf::Arena* arena, const Vector3& from);
  Vector3(::google::protobuf::Arena* arena, Vector3&& from) noexcept
      : Vector3(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:battle_c.Vector3)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vector3& from_msg);
    float x_;
    float y_;
    float z_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battle_5fc_2eproto;
};
// -------------------------------------------------------------------

class Vector2 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:battle_c.Vector2) */ {
 public:
  inline Vector2() : Vector2(nullptr) {}
  ~Vector2() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vector2* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vector2));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vector2(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vector2(const Vector2& from) : Vector2(nullptr, from) {}
  inline Vector2(Vector2&& from) noexcept
      : Vector2(nullptr, std::move(from)) {}
  inline Vector2& operator=(const Vector2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2& operator=(Vector2&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector2* internal_default_instance() {
    return reinterpret_cast<const Vector2*>(
        &_Vector2_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Vector2& a, Vector2& b) { a.Swap(&b); }
  inline void Swap(Vector2* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector2* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vector2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vector2& from) { Vector2::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vector2* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "battle_c.Vector2"; }

 protected:
  explicit Vector2(::google::protobuf::Arena* arena);
  Vector2(::google::protobuf::Arena* arena, const Vector2& from);
  Vector2(::google::protobuf::Arena* arena, Vector2&& from) noexcept
      : Vector2(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:battle_c.Vector2)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vector2& from_msg);
    ::int32_t x_;
    ::int32_t y_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battle_5fc_2eproto;
};
// -------------------------------------------------------------------

class ShootResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:battle_c.ShootResult) */ {
 public:
  inline ShootResult() : ShootResult(nullptr) {}
  ~ShootResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ShootResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ShootResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ShootResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline ShootResult(const ShootResult& from) : ShootResult(nullptr, from) {}
  inline ShootResult(ShootResult&& from) noexcept
      : ShootResult(nullptr, std::move(from)) {}
  inline ShootResult& operator=(const ShootResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShootResult& operator=(ShootResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShootResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShootResult* internal_default_instance() {
    return reinterpret_cast<const ShootResult*>(
        &_ShootResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ShootResult& a, ShootResult& b) { a.Swap(&b); }
  inline void Swap(ShootResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShootResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShootResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ShootResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShootResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ShootResult& from) { ShootResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ShootResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "battle_c.ShootResult"; }

 protected:
  explicit ShootResult(::google::protobuf::Arena* arena);
  ShootResult(::google::protobuf::Arena* arena, const ShootResult& from);
  ShootResult(::google::protobuf::Arena* arena, ShootResult&& from) noexcept
      : ShootResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetIdFieldNumber = 2,
    kDamagePointsFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kTargetDestroyedFieldNumber = 4,
  };
  // optional uint64 target_id = 2;
  bool has_target_id() const;
  void clear_target_id() ;
  ::uint64_t target_id() const;
  void set_target_id(::uint64_t value);

  private:
  ::uint64_t _internal_target_id() const;
  void _internal_set_target_id(::uint64_t value);

  public:
  // optional uint64 damage_points = 3;
  bool has_damage_points() const;
  void clear_damage_points() ;
  ::uint64_t damage_points() const;
  void set_damage_points(::uint64_t value);

  private:
  ::uint64_t _internal_damage_points() const;
  void _internal_set_damage_points(::uint64_t value);

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // optional bool target_destroyed = 4;
  bool has_target_destroyed() const;
  void clear_target_destroyed() ;
  bool target_destroyed() const;
  void set_target_destroyed(bool value);

  private:
  bool _internal_target_destroyed() const;
  void _internal_set_target_destroyed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:battle_c.ShootResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ShootResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t target_id_;
    ::uint64_t damage_points_;
    bool success_;
    bool target_destroyed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battle_5fc_2eproto;
};
// -------------------------------------------------------------------

class Shoot final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:battle_c.Shoot) */ {
 public:
  inline Shoot() : Shoot(nullptr) {}
  ~Shoot() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Shoot* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Shoot));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Shoot(
      ::google::protobuf::internal::ConstantInitialized);

  inline Shoot(const Shoot& from) : Shoot(nullptr, from) {}
  inline Shoot(Shoot&& from) noexcept
      : Shoot(nullptr, std::move(from)) {}
  inline Shoot& operator=(const Shoot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shoot& operator=(Shoot&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shoot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shoot* internal_default_instance() {
    return reinterpret_cast<const Shoot*>(
        &_Shoot_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Shoot& a, Shoot& b) { a.Swap(&b); }
  inline void Swap(Shoot* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shoot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shoot* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Shoot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Shoot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Shoot& from) { Shoot::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Shoot* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "battle_c.Shoot"; }

 protected:
  explicit Shoot(::google::protobuf::Arena* arena);
  Shoot(::google::protobuf::Arena* arena, const Shoot& from);
  Shoot(::google::protobuf::Arena* arena, Shoot&& from) noexcept
      : Shoot(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetIdFieldNumber = 1,
    kAngleFieldNumber = 2,
  };
  // optional uint64 target_id = 1;
  bool has_target_id() const;
  void clear_target_id() ;
  ::uint64_t target_id() const;
  void set_target_id(::uint64_t value);

  private:
  ::uint64_t _internal_target_id() const;
  void _internal_set_target_id(::uint64_t value);

  public:
  // optional float angle = 2;
  bool has_angle() const;
  void clear_angle() ;
  float angle() const;
  void set_angle(float value);

  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);

  public:
  // @@protoc_insertion_point(class_scope:battle_c.Shoot)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Shoot& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t target_id_;
    float angle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battle_5fc_2eproto;
};
// -------------------------------------------------------------------

class ClientInit final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:battle_c.ClientInit) */ {
 public:
  inline ClientInit() : ClientInit(nullptr) {}
  ~ClientInit() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClientInit* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClientInit));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClientInit(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClientInit(const ClientInit& from) : ClientInit(nullptr, from) {}
  inline ClientInit(ClientInit&& from) noexcept
      : ClientInit(nullptr, std::move(from)) {}
  inline ClientInit& operator=(const ClientInit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientInit& operator=(ClientInit&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientInit& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientInit* internal_default_instance() {
    return reinterpret_cast<const ClientInit*>(
        &_ClientInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ClientInit& a, ClientInit& b) { a.Swap(&b); }
  inline void Swap(ClientInit* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientInit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientInit* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ClientInit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClientInit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClientInit& from) { ClientInit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClientInit* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "battle_c.ClientInit"; }

 protected:
  explicit ClientInit(::google::protobuf::Arena* arena);
  ClientInit(::google::protobuf::Arena* arena, const ClientInit& from);
  ClientInit(::google::protobuf::Arena* arena, ClientInit&& from) noexcept
      : ClientInit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIsSpectatorFieldNumber = 1,
  };
  // bool is_spectator = 1;
  void clear_is_spectator() ;
  bool is_spectator() const;
  void set_is_spectator(bool value);

  private:
  bool _internal_is_spectator() const;
  void _internal_set_is_spectator(bool value);

  public:
  // @@protoc_insertion_point(class_scope:battle_c.ClientInit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClientInit& from_msg);
    bool is_spectator_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battle_5fc_2eproto;
};
// -------------------------------------------------------------------

class RadarReturn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:battle_c.RadarReturn) */ {
 public:
  inline RadarReturn() : RadarReturn(nullptr) {}
  ~RadarReturn() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RadarReturn* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RadarReturn));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RadarReturn(
      ::google::protobuf::internal::ConstantInitialized);

  inline RadarReturn(const RadarReturn& from) : RadarReturn(nullptr, from) {}
  inline RadarReturn(RadarReturn&& from) noexcept
      : RadarReturn(nullptr, std::move(from)) {}
  inline RadarReturn& operator=(const RadarReturn& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarReturn& operator=(RadarReturn&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadarReturn& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadarReturn* internal_default_instance() {
    return reinterpret_cast<const RadarReturn*>(
        &_RadarReturn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(RadarReturn& a, RadarReturn& b) { a.Swap(&b); }
  inline void Swap(RadarReturn* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadarReturn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadarReturn* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RadarReturn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RadarReturn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RadarReturn& from) { RadarReturn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RadarReturn* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "battle_c.RadarReturn"; }

 protected:
  explicit RadarReturn(::google::protobuf::Arena* arena);
  RadarReturn(::google::protobuf::Arena* arena, const RadarReturn& from);
  RadarReturn(::google::protobuf::Arena* arena, RadarReturn&& from) noexcept
      : RadarReturn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kIdFieldNumber = 1,
    kReturnTypeFieldNumber = 4,
  };
  // .battle_c.Vector3 position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::battle_c::Vector3& position() const;
  PROTOBUF_NODISCARD ::battle_c::Vector3* release_position();
  ::battle_c::Vector3* mutable_position();
  void set_allocated_position(::battle_c::Vector3* value);
  void unsafe_arena_set_allocated_position(::battle_c::Vector3* value);
  ::battle_c::Vector3* unsafe_arena_release_position();

  private:
  const ::battle_c::Vector3& _internal_position() const;
  ::battle_c::Vector3* _internal_mutable_position();

  public:
  // .battle_c.Vector3 speed = 3;
  bool has_speed() const;
  void clear_speed() ;
  const ::battle_c::Vector3& speed() const;
  PROTOBUF_NODISCARD ::battle_c::Vector3* release_speed();
  ::battle_c::Vector3* mutable_speed();
  void set_allocated_speed(::battle_c::Vector3* value);
  void unsafe_arena_set_allocated_speed(::battle_c::Vector3* value);
  ::battle_c::Vector3* unsafe_arena_release_speed();

  private:
  const ::battle_c::Vector3& _internal_speed() const;
  ::battle_c::Vector3* _internal_mutable_speed();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .battle_c.RadarReturnType return_type = 4;
  void clear_return_type() ;
  ::battle_c::RadarReturnType return_type() const;
  void set_return_type(::battle_c::RadarReturnType value);

  private:
  ::battle_c::RadarReturnType _internal_return_type() const;
  void _internal_set_return_type(::battle_c::RadarReturnType value);

  public:
  // @@protoc_insertion_point(class_scope:battle_c.RadarReturn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RadarReturn& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::battle_c::Vector3* position_;
    ::battle_c::Vector3* speed_;
    ::int32_t id_;
    int return_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battle_5fc_2eproto;
};
// -------------------------------------------------------------------

class PlayerData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:battle_c.PlayerData) */ {
 public:
  inline PlayerData() : PlayerData(nullptr) {}
  ~PlayerData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerData(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerData(const PlayerData& from) : PlayerData(nullptr, from) {}
  inline PlayerData(PlayerData&& from) noexcept
      : PlayerData(nullptr, std::move(from)) {}
  inline PlayerData& operator=(const PlayerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerData& operator=(PlayerData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerData* internal_default_instance() {
    return reinterpret_cast<const PlayerData*>(
        &_PlayerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(PlayerData& a, PlayerData& b) { a.Swap(&b); }
  inline void Swap(PlayerData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerData& from) { PlayerData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "battle_c.PlayerData"; }

 protected:
  explicit PlayerData(::google::protobuf::Arena* arena);
  PlayerData(::google::protobuf::Arena* arena, const PlayerData& from);
  PlayerData(::google::protobuf::Arena* arena, PlayerData&& from) noexcept
      : PlayerData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kIdFieldNumber = 1,
    kHealthFieldNumber = 4,
    kArmorFieldNumber = 5,
    kScoreFieldNumber = 6,
    kAliveFieldNumber = 7,
  };
  // optional .battle_c.Vector3 position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::battle_c::Vector3& position() const;
  PROTOBUF_NODISCARD ::battle_c::Vector3* release_position();
  ::battle_c::Vector3* mutable_position();
  void set_allocated_position(::battle_c::Vector3* value);
  void unsafe_arena_set_allocated_position(::battle_c::Vector3* value);
  ::battle_c::Vector3* unsafe_arena_release_position();

  private:
  const ::battle_c::Vector3& _internal_position() const;
  ::battle_c::Vector3* _internal_mutable_position();

  public:
  // optional .battle_c.Vector3 speed = 3;
  bool has_speed() const;
  void clear_speed() ;
  const ::battle_c::Vector3& speed() const;
  PROTOBUF_NODISCARD ::battle_c::Vector3* release_speed();
  ::battle_c::Vector3* mutable_speed();
  void set_allocated_speed(::battle_c::Vector3* value);
  void unsafe_arena_set_allocated_speed(::battle_c::Vector3* value);
  ::battle_c::Vector3* unsafe_arena_release_speed();

  private:
  const ::battle_c::Vector3& _internal_speed() const;
  ::battle_c::Vector3* _internal_mutable_speed();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 health = 4;
  void clear_health() ;
  ::int32_t health() const;
  void set_health(::int32_t value);

  private:
  ::int32_t _internal_health() const;
  void _internal_set_health(::int32_t value);

  public:
  // int32 armor = 5;
  void clear_armor() ;
  ::int32_t armor() const;
  void set_armor(::int32_t value);

  private:
  ::int32_t _internal_armor() const;
  void _internal_set_armor(::int32_t value);

  public:
  // int32 score = 6;
  void clear_score() ;
  ::int32_t score() const;
  void set_score(::int32_t value);

  private:
  ::int32_t _internal_score() const;
  void _internal_set_score(::int32_t value);

  public:
  // bool alive = 7;
  void clear_alive() ;
  bool alive() const;
  void set_alive(bool value);

  private:
  bool _internal_alive() const;
  void _internal_set_alive(bool value);

  public:
  // @@protoc_insertion_point(class_scope:battle_c.PlayerData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::battle_c::Vector3* position_;
    ::battle_c::Vector3* speed_;
    ::int32_t id_;
    ::int32_t health_;
    ::int32_t armor_;
    ::int32_t score_;
    bool alive_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battle_5fc_2eproto;
};
// -------------------------------------------------------------------

class ClientServerMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:battle_c.ClientServerMessage) */ {
 public:
  inline ClientServerMessage() : ClientServerMessage(nullptr) {}
  ~ClientServerMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClientServerMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClientServerMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClientServerMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClientServerMessage(const ClientServerMessage& from) : ClientServerMessage(nullptr, from) {}
  inline ClientServerMessage(ClientServerMessage&& from) noexcept
      : ClientServerMessage(nullptr, std::move(from)) {}
  inline ClientServerMessage& operator=(const ClientServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientServerMessage& operator=(ClientServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientServerMessage& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kSetSpeed = 2,
    kLimitDistance = 3,
    kRadarPing = 4,
    kGetWorldInfo = 5,
    kClientInit = 6,
    kShoot = 7,
    BODY_NOT_SET = 0,
  };
  static inline const ClientServerMessage* internal_default_instance() {
    return reinterpret_cast<const ClientServerMessage*>(
        &_ClientServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ClientServerMessage& a, ClientServerMessage& b) { a.Swap(&b); }
  inline void Swap(ClientServerMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientServerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientServerMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ClientServerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClientServerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClientServerMessage& from) { ClientServerMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClientServerMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "battle_c.ClientServerMessage"; }

 protected:
  explicit ClientServerMessage(::google::protobuf::Arena* arena);
  ClientServerMessage(::google::protobuf::Arena* arena, const ClientServerMessage& from);
  ClientServerMessage(::google::protobuf::Arena* arena, ClientServerMessage&& from) noexcept
      : ClientServerMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageIdFieldNumber = 1,
    kSetSpeedFieldNumber = 2,
    kLimitDistanceFieldNumber = 3,
    kRadarPingFieldNumber = 4,
    kGetWorldInfoFieldNumber = 5,
    kClientInitFieldNumber = 6,
    kShootFieldNumber = 7,
  };
  // optional int32 message_id = 1;
  bool has_message_id() const;
  void clear_message_id() ;
  ::int32_t message_id() const;
  void set_message_id(::int32_t value);

  private:
  ::int32_t _internal_message_id() const;
  void _internal_set_message_id(::int32_t value);

  public:
  // .battle_c.Vector3 set_speed = 2;
  bool has_set_speed() const;
  private:
  bool _internal_has_set_speed() const;

  public:
  void clear_set_speed() ;
  const ::battle_c::Vector3& set_speed() const;
  PROTOBUF_NODISCARD ::battle_c::Vector3* release_set_speed();
  ::battle_c::Vector3* mutable_set_speed();
  void set_allocated_set_speed(::battle_c::Vector3* value);
  void unsafe_arena_set_allocated_set_speed(::battle_c::Vector3* value);
  ::battle_c::Vector3* unsafe_arena_release_set_speed();

  private:
  const ::battle_c::Vector3& _internal_set_speed() const;
  ::battle_c::Vector3* _internal_mutable_set_speed();

  public:
  // .battle_c.Vector3 limit_distance = 3;
  bool has_limit_distance() const;
  private:
  bool _internal_has_limit_distance() const;

  public:
  void clear_limit_distance() ;
  const ::battle_c::Vector3& limit_distance() const;
  PROTOBUF_NODISCARD ::battle_c::Vector3* release_limit_distance();
  ::battle_c::Vector3* mutable_limit_distance();
  void set_allocated_limit_distance(::battle_c::Vector3* value);
  void unsafe_arena_set_allocated_limit_distance(::battle_c::Vector3* value);
  ::battle_c::Vector3* unsafe_arena_release_limit_distance();

  private:
  const ::battle_c::Vector3& _internal_limit_distance() const;
  ::battle_c::Vector3* _internal_mutable_limit_distance();

  public:
  // int32 radar_ping = 4;
  bool has_radar_ping() const;
  void clear_radar_ping() ;
  ::int32_t radar_ping() const;
  void set_radar_ping(::int32_t value);

  private:
  ::int32_t _internal_radar_ping() const;
  void _internal_set_radar_ping(::int32_t value);

  public:
  // bool get_world_info = 5;
  bool has_get_world_info() const;
  void clear_get_world_info() ;
  bool get_world_info() const;
  void set_get_world_info(bool value);

  private:
  bool _internal_get_world_info() const;
  void _internal_set_get_world_info(bool value);

  public:
  // .battle_c.ClientInit client_init = 6;
  bool has_client_init() const;
  private:
  bool _internal_has_client_init() const;

  public:
  void clear_client_init() ;
  const ::battle_c::ClientInit& client_init() const;
  PROTOBUF_NODISCARD ::battle_c::ClientInit* release_client_init();
  ::battle_c::ClientInit* mutable_client_init();
  void set_allocated_client_init(::battle_c::ClientInit* value);
  void unsafe_arena_set_allocated_client_init(::battle_c::ClientInit* value);
  ::battle_c::ClientInit* unsafe_arena_release_client_init();

  private:
  const ::battle_c::ClientInit& _internal_client_init() const;
  ::battle_c::ClientInit* _internal_mutable_client_init();

  public:
  // .battle_c.Shoot shoot = 7;
  bool has_shoot() const;
  private:
  bool _internal_has_shoot() const;

  public:
  void clear_shoot() ;
  const ::battle_c::Shoot& shoot() const;
  PROTOBUF_NODISCARD ::battle_c::Shoot* release_shoot();
  ::battle_c::Shoot* mutable_shoot();
  void set_allocated_shoot(::battle_c::Shoot* value);
  void unsafe_arena_set_allocated_shoot(::battle_c::Shoot* value);
  ::battle_c::Shoot* unsafe_arena_release_shoot();

  private:
  const ::battle_c::Shoot& _internal_shoot() const;
  ::battle_c::Shoot* _internal_mutable_shoot();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:battle_c.ClientServerMessage)
 private:
  class _Internal;
  void set_has_set_speed();
  void set_has_limit_distance();
  void set_has_radar_ping();
  void set_has_get_world_info();
  void set_has_client_init();
  void set_has_shoot();
  inline bool has_body() const;
  inline void clear_has_body();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 7, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClientServerMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t message_id_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::battle_c::Vector3* set_speed_;
      ::battle_c::Vector3* limit_distance_;
      ::int32_t radar_ping_;
      bool get_world_info_;
      ::battle_c::ClientInit* client_init_;
      ::battle_c::Shoot* shoot_;
    } body_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battle_5fc_2eproto;
};
// -------------------------------------------------------------------

class RadarResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:battle_c.RadarResult) */ {
 public:
  inline RadarResult() : RadarResult(nullptr) {}
  ~RadarResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RadarResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RadarResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RadarResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline RadarResult(const RadarResult& from) : RadarResult(nullptr, from) {}
  inline RadarResult(RadarResult&& from) noexcept
      : RadarResult(nullptr, std::move(from)) {}
  inline RadarResult& operator=(const RadarResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarResult& operator=(RadarResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadarResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadarResult* internal_default_instance() {
    return reinterpret_cast<const RadarResult*>(
        &_RadarResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(RadarResult& a, RadarResult& b) { a.Swap(&b); }
  inline void Swap(RadarResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadarResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadarResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RadarResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RadarResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RadarResult& from) { RadarResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RadarResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "battle_c.RadarResult"; }

 protected:
  explicit RadarResult(::google::protobuf::Arena* arena);
  RadarResult(::google::protobuf::Arena* arena, const RadarResult& from);
  RadarResult(::google::protobuf::Arena* arena, RadarResult&& from) noexcept
      : RadarResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRadarReturnFieldNumber = 1,
  };
  // repeated .battle_c.RadarReturn radar_return = 1;
  int radar_return_size() const;
  private:
  int _internal_radar_return_size() const;

  public:
  void clear_radar_return() ;
  ::battle_c::RadarReturn* mutable_radar_return(int index);
  ::google::protobuf::RepeatedPtrField<::battle_c::RadarReturn>* mutable_radar_return();

  private:
  const ::google::protobuf::RepeatedPtrField<::battle_c::RadarReturn>& _internal_radar_return() const;
  ::google::protobuf::RepeatedPtrField<::battle_c::RadarReturn>* _internal_mutable_radar_return();
  public:
  const ::battle_c::RadarReturn& radar_return(int index) const;
  ::battle_c::RadarReturn* add_radar_return();
  const ::google::protobuf::RepeatedPtrField<::battle_c::RadarReturn>& radar_return() const;
  // @@protoc_insertion_point(class_scope:battle_c.RadarResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RadarResult& from_msg);
    ::google::protobuf::RepeatedPtrField< ::battle_c::RadarReturn > radar_return_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battle_5fc_2eproto;
};
// -------------------------------------------------------------------

class PlayersSighted final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:battle_c.PlayersSighted) */ {
 public:
  inline PlayersSighted() : PlayersSighted(nullptr) {}
  ~PlayersSighted() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayersSighted* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayersSighted));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayersSighted(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayersSighted(const PlayersSighted& from) : PlayersSighted(nullptr, from) {}
  inline PlayersSighted(PlayersSighted&& from) noexcept
      : PlayersSighted(nullptr, std::move(from)) {}
  inline PlayersSighted& operator=(const PlayersSighted& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayersSighted& operator=(PlayersSighted&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayersSighted& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayersSighted* internal_default_instance() {
    return reinterpret_cast<const PlayersSighted*>(
        &_PlayersSighted_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(PlayersSighted& a, PlayersSighted& b) { a.Swap(&b); }
  inline void Swap(PlayersSighted* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayersSighted* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayersSighted* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayersSighted>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayersSighted& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayersSighted& from) { PlayersSighted::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayersSighted* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "battle_c.PlayersSighted"; }

 protected:
  explicit PlayersSighted(::google::protobuf::Arena* arena);
  PlayersSighted(::google::protobuf::Arena* arena, const PlayersSighted& from);
  PlayersSighted(::google::protobuf::Arena* arena, PlayersSighted&& from) noexcept
      : PlayersSighted(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayersFieldNumber = 2,
  };
  // repeated .battle_c.PlayerData players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::battle_c::PlayerData* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField<::battle_c::PlayerData>* mutable_players();

  private:
  const ::google::protobuf::RepeatedPtrField<::battle_c::PlayerData>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::battle_c::PlayerData>* _internal_mutable_players();
  public:
  const ::battle_c::PlayerData& players(int index) const;
  ::battle_c::PlayerData* add_players();
  const ::google::protobuf::RepeatedPtrField<::battle_c::PlayerData>& players() const;
  // @@protoc_insertion_point(class_scope:battle_c.PlayersSighted)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayersSighted& from_msg);
    ::google::protobuf::RepeatedPtrField< ::battle_c::PlayerData > players_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battle_5fc_2eproto;
};
// -------------------------------------------------------------------

class ServerClientMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:battle_c.ServerClientMessage) */ {
 public:
  inline ServerClientMessage() : ServerClientMessage(nullptr) {}
  ~ServerClientMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ServerClientMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ServerClientMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerClientMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ServerClientMessage(const ServerClientMessage& from) : ServerClientMessage(nullptr, from) {}
  inline ServerClientMessage(ServerClientMessage&& from) noexcept
      : ServerClientMessage(nullptr, std::move(from)) {}
  inline ServerClientMessage& operator=(const ServerClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerClientMessage& operator=(ServerClientMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerClientMessage& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kError = 2,
    kWorldOptions = 3,
    kPlayerData = 4,
    kPlayersSighted = 5,
    kRadarResult = 6,
    kShootResult = 7,
    BODY_NOT_SET = 0,
  };
  static inline const ServerClientMessage* internal_default_instance() {
    return reinterpret_cast<const ServerClientMessage*>(
        &_ServerClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ServerClientMessage& a, ServerClientMessage& b) { a.Swap(&b); }
  inline void Swap(ServerClientMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerClientMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerClientMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ServerClientMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServerClientMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ServerClientMessage& from) { ServerClientMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ServerClientMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "battle_c.ServerClientMessage"; }

 protected:
  explicit ServerClientMessage(::google::protobuf::Arena* arena);
  ServerClientMessage(::google::protobuf::Arena* arena, const ServerClientMessage& from);
  ServerClientMessage(::google::protobuf::Arena* arena, ServerClientMessage&& from) noexcept
      : ServerClientMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageIdFieldNumber = 1,
    kErrorFieldNumber = 2,
    kWorldOptionsFieldNumber = 3,
    kPlayerDataFieldNumber = 4,
    kPlayersSightedFieldNumber = 5,
    kRadarResultFieldNumber = 6,
    kShootResultFieldNumber = 7,
  };
  // optional int32 message_id = 1;
  bool has_message_id() const;
  void clear_message_id() ;
  ::int32_t message_id() const;
  void set_message_id(::int32_t value);

  private:
  ::int32_t _internal_message_id() const;
  void _internal_set_message_id(::int32_t value);

  public:
  // string error = 2;
  bool has_error() const;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // .battle_c.WorldOptions world_options = 3;
  bool has_world_options() const;
  private:
  bool _internal_has_world_options() const;

  public:
  void clear_world_options() ;
  const ::battle_c::WorldOptions& world_options() const;
  PROTOBUF_NODISCARD ::battle_c::WorldOptions* release_world_options();
  ::battle_c::WorldOptions* mutable_world_options();
  void set_allocated_world_options(::battle_c::WorldOptions* value);
  void unsafe_arena_set_allocated_world_options(::battle_c::WorldOptions* value);
  ::battle_c::WorldOptions* unsafe_arena_release_world_options();

  private:
  const ::battle_c::WorldOptions& _internal_world_options() const;
  ::battle_c::WorldOptions* _internal_mutable_world_options();

  public:
  // .battle_c.PlayerData player_data = 4;
  bool has_player_data() const;
  private:
  bool _internal_has_player_data() const;

  public:
  void clear_player_data() ;
  const ::battle_c::PlayerData& player_data() const;
  PROTOBUF_NODISCARD ::battle_c::PlayerData* release_player_data();
  ::battle_c::PlayerData* mutable_player_data();
  void set_allocated_player_data(::battle_c::PlayerData* value);
  void unsafe_arena_set_allocated_player_data(::battle_c::PlayerData* value);
  ::battle_c::PlayerData* unsafe_arena_release_player_data();

  private:
  const ::battle_c::PlayerData& _internal_player_data() const;
  ::battle_c::PlayerData* _internal_mutable_player_data();

  public:
  // .battle_c.PlayersSighted players_sighted = 5;
  bool has_players_sighted() const;
  private:
  bool _internal_has_players_sighted() const;

  public:
  void clear_players_sighted() ;
  const ::battle_c::PlayersSighted& players_sighted() const;
  PROTOBUF_NODISCARD ::battle_c::PlayersSighted* release_players_sighted();
  ::battle_c::PlayersSighted* mutable_players_sighted();
  void set_allocated_players_sighted(::battle_c::PlayersSighted* value);
  void unsafe_arena_set_allocated_players_sighted(::battle_c::PlayersSighted* value);
  ::battle_c::PlayersSighted* unsafe_arena_release_players_sighted();

  private:
  const ::battle_c::PlayersSighted& _internal_players_sighted() const;
  ::battle_c::PlayersSighted* _internal_mutable_players_sighted();

  public:
  // .battle_c.RadarResult radar_result = 6;
  bool has_radar_result() const;
  private:
  bool _internal_has_radar_result() const;

  public:
  void clear_radar_result() ;
  const ::battle_c::RadarResult& radar_result() const;
  PROTOBUF_NODISCARD ::battle_c::RadarResult* release_radar_result();
  ::battle_c::RadarResult* mutable_radar_result();
  void set_allocated_radar_result(::battle_c::RadarResult* value);
  void unsafe_arena_set_allocated_radar_result(::battle_c::RadarResult* value);
  ::battle_c::RadarResult* unsafe_arena_release_radar_result();

  private:
  const ::battle_c::RadarResult& _internal_radar_result() const;
  ::battle_c::RadarResult* _internal_mutable_radar_result();

  public:
  // .battle_c.ShootResult shoot_result = 7;
  bool has_shoot_result() const;
  private:
  bool _internal_has_shoot_result() const;

  public:
  void clear_shoot_result() ;
  const ::battle_c::ShootResult& shoot_result() const;
  PROTOBUF_NODISCARD ::battle_c::ShootResult* release_shoot_result();
  ::battle_c::ShootResult* mutable_shoot_result();
  void set_allocated_shoot_result(::battle_c::ShootResult* value);
  void unsafe_arena_set_allocated_shoot_result(::battle_c::ShootResult* value);
  ::battle_c::ShootResult* unsafe_arena_release_shoot_result();

  private:
  const ::battle_c::ShootResult& _internal_shoot_result() const;
  ::battle_c::ShootResult* _internal_mutable_shoot_result();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:battle_c.ServerClientMessage)
 private:
  class _Internal;
  void set_has_error();
  void set_has_world_options();
  void set_has_player_data();
  void set_has_players_sighted();
  void set_has_radar_result();
  void set_has_shoot_result();
  inline bool has_body() const;
  inline void clear_has_body();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 7, 5,
      42, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ServerClientMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t message_id_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr error_;
      ::battle_c::WorldOptions* world_options_;
      ::battle_c::PlayerData* player_data_;
      ::battle_c::PlayersSighted* players_sighted_;
      ::battle_c::RadarResult* radar_result_;
      ::battle_c::ShootResult* shoot_result_;
    } body_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battle_5fc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector2

// int32 x = 1;
inline void Vector2::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline ::int32_t Vector2::x() const {
  // @@protoc_insertion_point(field_get:battle_c.Vector2.x)
  return _internal_x();
}
inline void Vector2::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:battle_c.Vector2.x)
}
inline ::int32_t Vector2::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vector2::_internal_set_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// int32 y = 2;
inline void Vector2::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline ::int32_t Vector2::y() const {
  // @@protoc_insertion_point(field_get:battle_c.Vector2.y)
  return _internal_y();
}
inline void Vector2::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:battle_c.Vector2.y)
}
inline ::int32_t Vector2::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vector2::_internal_set_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:battle_c.Vector3.x)
  return _internal_x();
}
inline void Vector3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:battle_c.Vector3.x)
}
inline float Vector3::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vector3::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector3::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:battle_c.Vector3.y)
  return _internal_y();
}
inline void Vector3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:battle_c.Vector3.y)
}
inline float Vector3::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vector3::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Vector3::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:battle_c.Vector3.z)
  return _internal_z();
}
inline void Vector3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:battle_c.Vector3.z)
}
inline float Vector3::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vector3::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// PlayerData

// int32 id = 1;
inline void PlayerData::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
}
inline ::int32_t PlayerData::id() const {
  // @@protoc_insertion_point(field_get:battle_c.PlayerData.id)
  return _internal_id();
}
inline void PlayerData::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:battle_c.PlayerData.id)
}
inline ::int32_t PlayerData::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void PlayerData::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// optional .battle_c.Vector3 position = 2;
inline bool PlayerData::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void PlayerData::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::battle_c::Vector3& PlayerData::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::battle_c::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::battle_c::Vector3&>(::battle_c::_Vector3_default_instance_);
}
inline const ::battle_c::Vector3& PlayerData::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.PlayerData.position)
  return _internal_position();
}
inline void PlayerData::unsafe_arena_set_allocated_position(::battle_c::Vector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::battle_c::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.PlayerData.position)
}
inline ::battle_c::Vector3* PlayerData::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::battle_c::Vector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::battle_c::Vector3* PlayerData::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:battle_c.PlayerData.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::battle_c::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::battle_c::Vector3* PlayerData::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::battle_c::Vector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::battle_c::Vector3*>(p);
  }
  return _impl_.position_;
}
inline ::battle_c::Vector3* PlayerData::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::battle_c::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:battle_c.PlayerData.position)
  return _msg;
}
inline void PlayerData::set_allocated_position(::battle_c::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::battle_c::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:battle_c.PlayerData.position)
}

// optional .battle_c.Vector3 speed = 3;
inline bool PlayerData::has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speed_ != nullptr);
  return value;
}
inline void PlayerData::clear_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.speed_ != nullptr) _impl_.speed_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::battle_c::Vector3& PlayerData::_internal_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::battle_c::Vector3* p = _impl_.speed_;
  return p != nullptr ? *p : reinterpret_cast<const ::battle_c::Vector3&>(::battle_c::_Vector3_default_instance_);
}
inline const ::battle_c::Vector3& PlayerData::speed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.PlayerData.speed)
  return _internal_speed();
}
inline void PlayerData::unsafe_arena_set_allocated_speed(::battle_c::Vector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_);
  }
  _impl_.speed_ = reinterpret_cast<::battle_c::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.PlayerData.speed)
}
inline ::battle_c::Vector3* PlayerData::release_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::battle_c::Vector3* released = _impl_.speed_;
  _impl_.speed_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::battle_c::Vector3* PlayerData::unsafe_arena_release_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:battle_c.PlayerData.speed)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::battle_c::Vector3* temp = _impl_.speed_;
  _impl_.speed_ = nullptr;
  return temp;
}
inline ::battle_c::Vector3* PlayerData::_internal_mutable_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.speed_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::battle_c::Vector3>(GetArena());
    _impl_.speed_ = reinterpret_cast<::battle_c::Vector3*>(p);
  }
  return _impl_.speed_;
}
inline ::battle_c::Vector3* PlayerData::mutable_speed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::battle_c::Vector3* _msg = _internal_mutable_speed();
  // @@protoc_insertion_point(field_mutable:battle_c.PlayerData.speed)
  return _msg;
}
inline void PlayerData::set_allocated_speed(::battle_c::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.speed_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.speed_ = reinterpret_cast<::battle_c::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:battle_c.PlayerData.speed)
}

// int32 health = 4;
inline void PlayerData::clear_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ = 0;
}
inline ::int32_t PlayerData::health() const {
  // @@protoc_insertion_point(field_get:battle_c.PlayerData.health)
  return _internal_health();
}
inline void PlayerData::set_health(::int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:battle_c.PlayerData.health)
}
inline ::int32_t PlayerData::_internal_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_;
}
inline void PlayerData::_internal_set_health(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ = value;
}

// int32 armor = 5;
inline void PlayerData::clear_armor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.armor_ = 0;
}
inline ::int32_t PlayerData::armor() const {
  // @@protoc_insertion_point(field_get:battle_c.PlayerData.armor)
  return _internal_armor();
}
inline void PlayerData::set_armor(::int32_t value) {
  _internal_set_armor(value);
  // @@protoc_insertion_point(field_set:battle_c.PlayerData.armor)
}
inline ::int32_t PlayerData::_internal_armor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.armor_;
}
inline void PlayerData::_internal_set_armor(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.armor_ = value;
}

// int32 score = 6;
inline void PlayerData::clear_score() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_ = 0;
}
inline ::int32_t PlayerData::score() const {
  // @@protoc_insertion_point(field_get:battle_c.PlayerData.score)
  return _internal_score();
}
inline void PlayerData::set_score(::int32_t value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:battle_c.PlayerData.score)
}
inline ::int32_t PlayerData::_internal_score() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_;
}
inline void PlayerData::_internal_set_score(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_ = value;
}

// bool alive = 7;
inline void PlayerData::clear_alive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alive_ = false;
}
inline bool PlayerData::alive() const {
  // @@protoc_insertion_point(field_get:battle_c.PlayerData.alive)
  return _internal_alive();
}
inline void PlayerData::set_alive(bool value) {
  _internal_set_alive(value);
  // @@protoc_insertion_point(field_set:battle_c.PlayerData.alive)
}
inline bool PlayerData::_internal_alive() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alive_;
}
inline void PlayerData::_internal_set_alive(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alive_ = value;
}

// -------------------------------------------------------------------

// RadarReturn

// int32 id = 1;
inline void RadarReturn::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
}
inline ::int32_t RadarReturn::id() const {
  // @@protoc_insertion_point(field_get:battle_c.RadarReturn.id)
  return _internal_id();
}
inline void RadarReturn::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:battle_c.RadarReturn.id)
}
inline ::int32_t RadarReturn::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void RadarReturn::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .battle_c.Vector3 position = 2;
inline bool RadarReturn::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void RadarReturn::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::battle_c::Vector3& RadarReturn::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::battle_c::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::battle_c::Vector3&>(::battle_c::_Vector3_default_instance_);
}
inline const ::battle_c::Vector3& RadarReturn::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.RadarReturn.position)
  return _internal_position();
}
inline void RadarReturn::unsafe_arena_set_allocated_position(::battle_c::Vector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::battle_c::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.RadarReturn.position)
}
inline ::battle_c::Vector3* RadarReturn::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::battle_c::Vector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::battle_c::Vector3* RadarReturn::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:battle_c.RadarReturn.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::battle_c::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::battle_c::Vector3* RadarReturn::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::battle_c::Vector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::battle_c::Vector3*>(p);
  }
  return _impl_.position_;
}
inline ::battle_c::Vector3* RadarReturn::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::battle_c::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:battle_c.RadarReturn.position)
  return _msg;
}
inline void RadarReturn::set_allocated_position(::battle_c::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::battle_c::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:battle_c.RadarReturn.position)
}

// .battle_c.Vector3 speed = 3;
inline bool RadarReturn::has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speed_ != nullptr);
  return value;
}
inline void RadarReturn::clear_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.speed_ != nullptr) _impl_.speed_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::battle_c::Vector3& RadarReturn::_internal_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::battle_c::Vector3* p = _impl_.speed_;
  return p != nullptr ? *p : reinterpret_cast<const ::battle_c::Vector3&>(::battle_c::_Vector3_default_instance_);
}
inline const ::battle_c::Vector3& RadarReturn::speed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.RadarReturn.speed)
  return _internal_speed();
}
inline void RadarReturn::unsafe_arena_set_allocated_speed(::battle_c::Vector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_);
  }
  _impl_.speed_ = reinterpret_cast<::battle_c::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.RadarReturn.speed)
}
inline ::battle_c::Vector3* RadarReturn::release_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::battle_c::Vector3* released = _impl_.speed_;
  _impl_.speed_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::battle_c::Vector3* RadarReturn::unsafe_arena_release_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:battle_c.RadarReturn.speed)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::battle_c::Vector3* temp = _impl_.speed_;
  _impl_.speed_ = nullptr;
  return temp;
}
inline ::battle_c::Vector3* RadarReturn::_internal_mutable_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.speed_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::battle_c::Vector3>(GetArena());
    _impl_.speed_ = reinterpret_cast<::battle_c::Vector3*>(p);
  }
  return _impl_.speed_;
}
inline ::battle_c::Vector3* RadarReturn::mutable_speed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::battle_c::Vector3* _msg = _internal_mutable_speed();
  // @@protoc_insertion_point(field_mutable:battle_c.RadarReturn.speed)
  return _msg;
}
inline void RadarReturn::set_allocated_speed(::battle_c::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.speed_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.speed_ = reinterpret_cast<::battle_c::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:battle_c.RadarReturn.speed)
}

// .battle_c.RadarReturnType return_type = 4;
inline void RadarReturn::clear_return_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.return_type_ = 0;
}
inline ::battle_c::RadarReturnType RadarReturn::return_type() const {
  // @@protoc_insertion_point(field_get:battle_c.RadarReturn.return_type)
  return _internal_return_type();
}
inline void RadarReturn::set_return_type(::battle_c::RadarReturnType value) {
  _internal_set_return_type(value);
  // @@protoc_insertion_point(field_set:battle_c.RadarReturn.return_type)
}
inline ::battle_c::RadarReturnType RadarReturn::_internal_return_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::battle_c::RadarReturnType>(_impl_.return_type_);
}
inline void RadarReturn::_internal_set_return_type(::battle_c::RadarReturnType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.return_type_ = value;
}

// -------------------------------------------------------------------

// Shoot

// optional uint64 target_id = 1;
inline bool Shoot::has_target_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Shoot::clear_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t Shoot::target_id() const {
  // @@protoc_insertion_point(field_get:battle_c.Shoot.target_id)
  return _internal_target_id();
}
inline void Shoot::set_target_id(::uint64_t value) {
  _internal_set_target_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:battle_c.Shoot.target_id)
}
inline ::uint64_t Shoot::_internal_target_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_id_;
}
inline void Shoot::_internal_set_target_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_ = value;
}

// optional float angle = 2;
inline bool Shoot::has_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Shoot::clear_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Shoot::angle() const {
  // @@protoc_insertion_point(field_get:battle_c.Shoot.angle)
  return _internal_angle();
}
inline void Shoot::set_angle(float value) {
  _internal_set_angle(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:battle_c.Shoot.angle)
}
inline float Shoot::_internal_angle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.angle_;
}
inline void Shoot::_internal_set_angle(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// ClientInit

// bool is_spectator = 1;
inline void ClientInit::clear_is_spectator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_spectator_ = false;
}
inline bool ClientInit::is_spectator() const {
  // @@protoc_insertion_point(field_get:battle_c.ClientInit.is_spectator)
  return _internal_is_spectator();
}
inline void ClientInit::set_is_spectator(bool value) {
  _internal_set_is_spectator(value);
  // @@protoc_insertion_point(field_set:battle_c.ClientInit.is_spectator)
}
inline bool ClientInit::_internal_is_spectator() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_spectator_;
}
inline void ClientInit::_internal_set_is_spectator(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_spectator_ = value;
}

// -------------------------------------------------------------------

// ClientServerMessage

// optional int32 message_id = 1;
inline bool ClientServerMessage::has_message_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ClientServerMessage::clear_message_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ClientServerMessage::message_id() const {
  // @@protoc_insertion_point(field_get:battle_c.ClientServerMessage.message_id)
  return _internal_message_id();
}
inline void ClientServerMessage::set_message_id(::int32_t value) {
  _internal_set_message_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:battle_c.ClientServerMessage.message_id)
}
inline ::int32_t ClientServerMessage::_internal_message_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_id_;
}
inline void ClientServerMessage::_internal_set_message_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_id_ = value;
}

// .battle_c.Vector3 set_speed = 2;
inline bool ClientServerMessage::has_set_speed() const {
  return body_case() == kSetSpeed;
}
inline bool ClientServerMessage::_internal_has_set_speed() const {
  return body_case() == kSetSpeed;
}
inline void ClientServerMessage::set_has_set_speed() {
  _impl_._oneof_case_[0] = kSetSpeed;
}
inline void ClientServerMessage::clear_set_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kSetSpeed) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.set_speed_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.set_speed_);
    }
    clear_has_body();
  }
}
inline ::battle_c::Vector3* ClientServerMessage::release_set_speed() {
  // @@protoc_insertion_point(field_release:battle_c.ClientServerMessage.set_speed)
  if (body_case() == kSetSpeed) {
    clear_has_body();
    auto* temp = _impl_.body_.set_speed_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.set_speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::battle_c::Vector3& ClientServerMessage::_internal_set_speed() const {
  return body_case() == kSetSpeed ? *_impl_.body_.set_speed_ : reinterpret_cast<::battle_c::Vector3&>(::battle_c::_Vector3_default_instance_);
}
inline const ::battle_c::Vector3& ClientServerMessage::set_speed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.ClientServerMessage.set_speed)
  return _internal_set_speed();
}
inline ::battle_c::Vector3* ClientServerMessage::unsafe_arena_release_set_speed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:battle_c.ClientServerMessage.set_speed)
  if (body_case() == kSetSpeed) {
    clear_has_body();
    auto* temp = _impl_.body_.set_speed_;
    _impl_.body_.set_speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientServerMessage::unsafe_arena_set_allocated_set_speed(::battle_c::Vector3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_set_speed();
    _impl_.body_.set_speed_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.ClientServerMessage.set_speed)
}
inline ::battle_c::Vector3* ClientServerMessage::_internal_mutable_set_speed() {
  if (body_case() != kSetSpeed) {
    clear_body();
    set_has_set_speed();
    _impl_.body_.set_speed_ =
        ::google::protobuf::Message::DefaultConstruct<::battle_c::Vector3>(GetArena());
  }
  return _impl_.body_.set_speed_;
}
inline ::battle_c::Vector3* ClientServerMessage::mutable_set_speed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::battle_c::Vector3* _msg = _internal_mutable_set_speed();
  // @@protoc_insertion_point(field_mutable:battle_c.ClientServerMessage.set_speed)
  return _msg;
}

// .battle_c.Vector3 limit_distance = 3;
inline bool ClientServerMessage::has_limit_distance() const {
  return body_case() == kLimitDistance;
}
inline bool ClientServerMessage::_internal_has_limit_distance() const {
  return body_case() == kLimitDistance;
}
inline void ClientServerMessage::set_has_limit_distance() {
  _impl_._oneof_case_[0] = kLimitDistance;
}
inline void ClientServerMessage::clear_limit_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kLimitDistance) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.limit_distance_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.limit_distance_);
    }
    clear_has_body();
  }
}
inline ::battle_c::Vector3* ClientServerMessage::release_limit_distance() {
  // @@protoc_insertion_point(field_release:battle_c.ClientServerMessage.limit_distance)
  if (body_case() == kLimitDistance) {
    clear_has_body();
    auto* temp = _impl_.body_.limit_distance_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.limit_distance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::battle_c::Vector3& ClientServerMessage::_internal_limit_distance() const {
  return body_case() == kLimitDistance ? *_impl_.body_.limit_distance_ : reinterpret_cast<::battle_c::Vector3&>(::battle_c::_Vector3_default_instance_);
}
inline const ::battle_c::Vector3& ClientServerMessage::limit_distance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.ClientServerMessage.limit_distance)
  return _internal_limit_distance();
}
inline ::battle_c::Vector3* ClientServerMessage::unsafe_arena_release_limit_distance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:battle_c.ClientServerMessage.limit_distance)
  if (body_case() == kLimitDistance) {
    clear_has_body();
    auto* temp = _impl_.body_.limit_distance_;
    _impl_.body_.limit_distance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientServerMessage::unsafe_arena_set_allocated_limit_distance(::battle_c::Vector3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_limit_distance();
    _impl_.body_.limit_distance_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.ClientServerMessage.limit_distance)
}
inline ::battle_c::Vector3* ClientServerMessage::_internal_mutable_limit_distance() {
  if (body_case() != kLimitDistance) {
    clear_body();
    set_has_limit_distance();
    _impl_.body_.limit_distance_ =
        ::google::protobuf::Message::DefaultConstruct<::battle_c::Vector3>(GetArena());
  }
  return _impl_.body_.limit_distance_;
}
inline ::battle_c::Vector3* ClientServerMessage::mutable_limit_distance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::battle_c::Vector3* _msg = _internal_mutable_limit_distance();
  // @@protoc_insertion_point(field_mutable:battle_c.ClientServerMessage.limit_distance)
  return _msg;
}

// int32 radar_ping = 4;
inline bool ClientServerMessage::has_radar_ping() const {
  return body_case() == kRadarPing;
}
inline void ClientServerMessage::set_has_radar_ping() {
  _impl_._oneof_case_[0] = kRadarPing;
}
inline void ClientServerMessage::clear_radar_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kRadarPing) {
    _impl_.body_.radar_ping_ = 0;
    clear_has_body();
  }
}
inline ::int32_t ClientServerMessage::radar_ping() const {
  // @@protoc_insertion_point(field_get:battle_c.ClientServerMessage.radar_ping)
  return _internal_radar_ping();
}
inline void ClientServerMessage::set_radar_ping(::int32_t value) {
  if (body_case() != kRadarPing) {
    clear_body();
    set_has_radar_ping();
  }
  _impl_.body_.radar_ping_ = value;
  // @@protoc_insertion_point(field_set:battle_c.ClientServerMessage.radar_ping)
}
inline ::int32_t ClientServerMessage::_internal_radar_ping() const {
  if (body_case() == kRadarPing) {
    return _impl_.body_.radar_ping_;
  }
  return 0;
}

// bool get_world_info = 5;
inline bool ClientServerMessage::has_get_world_info() const {
  return body_case() == kGetWorldInfo;
}
inline void ClientServerMessage::set_has_get_world_info() {
  _impl_._oneof_case_[0] = kGetWorldInfo;
}
inline void ClientServerMessage::clear_get_world_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kGetWorldInfo) {
    _impl_.body_.get_world_info_ = false;
    clear_has_body();
  }
}
inline bool ClientServerMessage::get_world_info() const {
  // @@protoc_insertion_point(field_get:battle_c.ClientServerMessage.get_world_info)
  return _internal_get_world_info();
}
inline void ClientServerMessage::set_get_world_info(bool value) {
  if (body_case() != kGetWorldInfo) {
    clear_body();
    set_has_get_world_info();
  }
  _impl_.body_.get_world_info_ = value;
  // @@protoc_insertion_point(field_set:battle_c.ClientServerMessage.get_world_info)
}
inline bool ClientServerMessage::_internal_get_world_info() const {
  if (body_case() == kGetWorldInfo) {
    return _impl_.body_.get_world_info_;
  }
  return false;
}

// .battle_c.ClientInit client_init = 6;
inline bool ClientServerMessage::has_client_init() const {
  return body_case() == kClientInit;
}
inline bool ClientServerMessage::_internal_has_client_init() const {
  return body_case() == kClientInit;
}
inline void ClientServerMessage::set_has_client_init() {
  _impl_._oneof_case_[0] = kClientInit;
}
inline void ClientServerMessage::clear_client_init() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kClientInit) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.client_init_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.client_init_);
    }
    clear_has_body();
  }
}
inline ::battle_c::ClientInit* ClientServerMessage::release_client_init() {
  // @@protoc_insertion_point(field_release:battle_c.ClientServerMessage.client_init)
  if (body_case() == kClientInit) {
    clear_has_body();
    auto* temp = _impl_.body_.client_init_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.client_init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::battle_c::ClientInit& ClientServerMessage::_internal_client_init() const {
  return body_case() == kClientInit ? *_impl_.body_.client_init_ : reinterpret_cast<::battle_c::ClientInit&>(::battle_c::_ClientInit_default_instance_);
}
inline const ::battle_c::ClientInit& ClientServerMessage::client_init() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.ClientServerMessage.client_init)
  return _internal_client_init();
}
inline ::battle_c::ClientInit* ClientServerMessage::unsafe_arena_release_client_init() {
  // @@protoc_insertion_point(field_unsafe_arena_release:battle_c.ClientServerMessage.client_init)
  if (body_case() == kClientInit) {
    clear_has_body();
    auto* temp = _impl_.body_.client_init_;
    _impl_.body_.client_init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientServerMessage::unsafe_arena_set_allocated_client_init(::battle_c::ClientInit* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_client_init();
    _impl_.body_.client_init_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.ClientServerMessage.client_init)
}
inline ::battle_c::ClientInit* ClientServerMessage::_internal_mutable_client_init() {
  if (body_case() != kClientInit) {
    clear_body();
    set_has_client_init();
    _impl_.body_.client_init_ =
        ::google::protobuf::Message::DefaultConstruct<::battle_c::ClientInit>(GetArena());
  }
  return _impl_.body_.client_init_;
}
inline ::battle_c::ClientInit* ClientServerMessage::mutable_client_init() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::battle_c::ClientInit* _msg = _internal_mutable_client_init();
  // @@protoc_insertion_point(field_mutable:battle_c.ClientServerMessage.client_init)
  return _msg;
}

// .battle_c.Shoot shoot = 7;
inline bool ClientServerMessage::has_shoot() const {
  return body_case() == kShoot;
}
inline bool ClientServerMessage::_internal_has_shoot() const {
  return body_case() == kShoot;
}
inline void ClientServerMessage::set_has_shoot() {
  _impl_._oneof_case_[0] = kShoot;
}
inline void ClientServerMessage::clear_shoot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kShoot) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.shoot_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.shoot_);
    }
    clear_has_body();
  }
}
inline ::battle_c::Shoot* ClientServerMessage::release_shoot() {
  // @@protoc_insertion_point(field_release:battle_c.ClientServerMessage.shoot)
  if (body_case() == kShoot) {
    clear_has_body();
    auto* temp = _impl_.body_.shoot_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.shoot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::battle_c::Shoot& ClientServerMessage::_internal_shoot() const {
  return body_case() == kShoot ? *_impl_.body_.shoot_ : reinterpret_cast<::battle_c::Shoot&>(::battle_c::_Shoot_default_instance_);
}
inline const ::battle_c::Shoot& ClientServerMessage::shoot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.ClientServerMessage.shoot)
  return _internal_shoot();
}
inline ::battle_c::Shoot* ClientServerMessage::unsafe_arena_release_shoot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:battle_c.ClientServerMessage.shoot)
  if (body_case() == kShoot) {
    clear_has_body();
    auto* temp = _impl_.body_.shoot_;
    _impl_.body_.shoot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientServerMessage::unsafe_arena_set_allocated_shoot(::battle_c::Shoot* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_shoot();
    _impl_.body_.shoot_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.ClientServerMessage.shoot)
}
inline ::battle_c::Shoot* ClientServerMessage::_internal_mutable_shoot() {
  if (body_case() != kShoot) {
    clear_body();
    set_has_shoot();
    _impl_.body_.shoot_ =
        ::google::protobuf::Message::DefaultConstruct<::battle_c::Shoot>(GetArena());
  }
  return _impl_.body_.shoot_;
}
inline ::battle_c::Shoot* ClientServerMessage::mutable_shoot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::battle_c::Shoot* _msg = _internal_mutable_shoot();
  // @@protoc_insertion_point(field_mutable:battle_c.ClientServerMessage.shoot)
  return _msg;
}

inline bool ClientServerMessage::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void ClientServerMessage::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline ClientServerMessage::BodyCase ClientServerMessage::body_case() const {
  return ClientServerMessage::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WorldOptions

// int32 map_x = 1;
inline void WorldOptions::clear_map_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_x_ = 0;
}
inline ::int32_t WorldOptions::map_x() const {
  // @@protoc_insertion_point(field_get:battle_c.WorldOptions.map_x)
  return _internal_map_x();
}
inline void WorldOptions::set_map_x(::int32_t value) {
  _internal_set_map_x(value);
  // @@protoc_insertion_point(field_set:battle_c.WorldOptions.map_x)
}
inline ::int32_t WorldOptions::_internal_map_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_x_;
}
inline void WorldOptions::_internal_set_map_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_x_ = value;
}

// int32 map_y = 2;
inline void WorldOptions::clear_map_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_y_ = 0;
}
inline ::int32_t WorldOptions::map_y() const {
  // @@protoc_insertion_point(field_get:battle_c.WorldOptions.map_y)
  return _internal_map_y();
}
inline void WorldOptions::set_map_y(::int32_t value) {
  _internal_set_map_y(value);
  // @@protoc_insertion_point(field_set:battle_c.WorldOptions.map_y)
}
inline ::int32_t WorldOptions::_internal_map_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_y_;
}
inline void WorldOptions::_internal_set_map_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_y_ = value;
}

// bool grid_based = 3;
inline void WorldOptions::clear_grid_based() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_based_ = false;
}
inline bool WorldOptions::grid_based() const {
  // @@protoc_insertion_point(field_get:battle_c.WorldOptions.grid_based)
  return _internal_grid_based();
}
inline void WorldOptions::set_grid_based(bool value) {
  _internal_set_grid_based(value);
  // @@protoc_insertion_point(field_set:battle_c.WorldOptions.grid_based)
}
inline bool WorldOptions::_internal_grid_based() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.grid_based_;
}
inline void WorldOptions::_internal_set_grid_based(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_based_ = value;
}

// float grid_resolution = 4;
inline void WorldOptions::clear_grid_resolution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_resolution_ = 0;
}
inline float WorldOptions::grid_resolution() const {
  // @@protoc_insertion_point(field_get:battle_c.WorldOptions.grid_resolution)
  return _internal_grid_resolution();
}
inline void WorldOptions::set_grid_resolution(float value) {
  _internal_set_grid_resolution(value);
  // @@protoc_insertion_point(field_set:battle_c.WorldOptions.grid_resolution)
}
inline float WorldOptions::_internal_grid_resolution() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.grid_resolution_;
}
inline void WorldOptions::_internal_set_grid_resolution(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_resolution_ = value;
}

// int32 max_players = 5;
inline void WorldOptions::clear_max_players() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_players_ = 0;
}
inline ::int32_t WorldOptions::max_players() const {
  // @@protoc_insertion_point(field_get:battle_c.WorldOptions.max_players)
  return _internal_max_players();
}
inline void WorldOptions::set_max_players(::int32_t value) {
  _internal_set_max_players(value);
  // @@protoc_insertion_point(field_set:battle_c.WorldOptions.max_players)
}
inline ::int32_t WorldOptions::_internal_max_players() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_players_;
}
inline void WorldOptions::_internal_set_max_players(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_players_ = value;
}

// bool auto_shoot_allowed = 6;
inline void WorldOptions::clear_auto_shoot_allowed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_shoot_allowed_ = false;
}
inline bool WorldOptions::auto_shoot_allowed() const {
  // @@protoc_insertion_point(field_get:battle_c.WorldOptions.auto_shoot_allowed)
  return _internal_auto_shoot_allowed();
}
inline void WorldOptions::set_auto_shoot_allowed(bool value) {
  _internal_set_auto_shoot_allowed(value);
  // @@protoc_insertion_point(field_set:battle_c.WorldOptions.auto_shoot_allowed)
}
inline bool WorldOptions::_internal_auto_shoot_allowed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auto_shoot_allowed_;
}
inline void WorldOptions::_internal_set_auto_shoot_allowed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_shoot_allowed_ = value;
}

// bool radar_enabled = 7;
inline void WorldOptions::clear_radar_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.radar_enabled_ = false;
}
inline bool WorldOptions::radar_enabled() const {
  // @@protoc_insertion_point(field_get:battle_c.WorldOptions.radar_enabled)
  return _internal_radar_enabled();
}
inline void WorldOptions::set_radar_enabled(bool value) {
  _internal_set_radar_enabled(value);
  // @@protoc_insertion_point(field_set:battle_c.WorldOptions.radar_enabled)
}
inline bool WorldOptions::_internal_radar_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.radar_enabled_;
}
inline void WorldOptions::_internal_set_radar_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.radar_enabled_ = value;
}

// -------------------------------------------------------------------

// RadarResult

// repeated .battle_c.RadarReturn radar_return = 1;
inline int RadarResult::_internal_radar_return_size() const {
  return _internal_radar_return().size();
}
inline int RadarResult::radar_return_size() const {
  return _internal_radar_return_size();
}
inline void RadarResult::clear_radar_return() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.radar_return_.Clear();
}
inline ::battle_c::RadarReturn* RadarResult::mutable_radar_return(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:battle_c.RadarResult.radar_return)
  return _internal_mutable_radar_return()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::battle_c::RadarReturn>* RadarResult::mutable_radar_return()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:battle_c.RadarResult.radar_return)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_radar_return();
}
inline const ::battle_c::RadarReturn& RadarResult::radar_return(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.RadarResult.radar_return)
  return _internal_radar_return().Get(index);
}
inline ::battle_c::RadarReturn* RadarResult::add_radar_return() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::battle_c::RadarReturn* _add = _internal_mutable_radar_return()->Add();
  // @@protoc_insertion_point(field_add:battle_c.RadarResult.radar_return)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::battle_c::RadarReturn>& RadarResult::radar_return() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:battle_c.RadarResult.radar_return)
  return _internal_radar_return();
}
inline const ::google::protobuf::RepeatedPtrField<::battle_c::RadarReturn>&
RadarResult::_internal_radar_return() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.radar_return_;
}
inline ::google::protobuf::RepeatedPtrField<::battle_c::RadarReturn>*
RadarResult::_internal_mutable_radar_return() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.radar_return_;
}

// -------------------------------------------------------------------

// PlayersSighted

// repeated .battle_c.PlayerData players = 2;
inline int PlayersSighted::_internal_players_size() const {
  return _internal_players().size();
}
inline int PlayersSighted::players_size() const {
  return _internal_players_size();
}
inline void PlayersSighted::clear_players() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.players_.Clear();
}
inline ::battle_c::PlayerData* PlayersSighted::mutable_players(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:battle_c.PlayersSighted.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::battle_c::PlayerData>* PlayersSighted::mutable_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:battle_c.PlayersSighted.players)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_players();
}
inline const ::battle_c::PlayerData& PlayersSighted::players(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.PlayersSighted.players)
  return _internal_players().Get(index);
}
inline ::battle_c::PlayerData* PlayersSighted::add_players() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::battle_c::PlayerData* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:battle_c.PlayersSighted.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::battle_c::PlayerData>& PlayersSighted::players() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:battle_c.PlayersSighted.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::battle_c::PlayerData>&
PlayersSighted::_internal_players() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::battle_c::PlayerData>*
PlayersSighted::_internal_mutable_players() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.players_;
}

// -------------------------------------------------------------------

// ShootResult

// bool success = 1;
inline void ShootResult::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool ShootResult::success() const {
  // @@protoc_insertion_point(field_get:battle_c.ShootResult.success)
  return _internal_success();
}
inline void ShootResult::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:battle_c.ShootResult.success)
}
inline bool ShootResult::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ShootResult::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// optional uint64 target_id = 2;
inline bool ShootResult::has_target_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ShootResult::clear_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t ShootResult::target_id() const {
  // @@protoc_insertion_point(field_get:battle_c.ShootResult.target_id)
  return _internal_target_id();
}
inline void ShootResult::set_target_id(::uint64_t value) {
  _internal_set_target_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:battle_c.ShootResult.target_id)
}
inline ::uint64_t ShootResult::_internal_target_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_id_;
}
inline void ShootResult::_internal_set_target_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_ = value;
}

// optional uint64 damage_points = 3;
inline bool ShootResult::has_damage_points() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ShootResult::clear_damage_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_points_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t ShootResult::damage_points() const {
  // @@protoc_insertion_point(field_get:battle_c.ShootResult.damage_points)
  return _internal_damage_points();
}
inline void ShootResult::set_damage_points(::uint64_t value) {
  _internal_set_damage_points(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:battle_c.ShootResult.damage_points)
}
inline ::uint64_t ShootResult::_internal_damage_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_points_;
}
inline void ShootResult::_internal_set_damage_points(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_points_ = value;
}

// optional bool target_destroyed = 4;
inline bool ShootResult::has_target_destroyed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ShootResult::clear_target_destroyed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_destroyed_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ShootResult::target_destroyed() const {
  // @@protoc_insertion_point(field_get:battle_c.ShootResult.target_destroyed)
  return _internal_target_destroyed();
}
inline void ShootResult::set_target_destroyed(bool value) {
  _internal_set_target_destroyed(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:battle_c.ShootResult.target_destroyed)
}
inline bool ShootResult::_internal_target_destroyed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_destroyed_;
}
inline void ShootResult::_internal_set_target_destroyed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_destroyed_ = value;
}

// -------------------------------------------------------------------

// ServerClientMessage

// optional int32 message_id = 1;
inline bool ServerClientMessage::has_message_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ServerClientMessage::clear_message_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ServerClientMessage::message_id() const {
  // @@protoc_insertion_point(field_get:battle_c.ServerClientMessage.message_id)
  return _internal_message_id();
}
inline void ServerClientMessage::set_message_id(::int32_t value) {
  _internal_set_message_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:battle_c.ServerClientMessage.message_id)
}
inline ::int32_t ServerClientMessage::_internal_message_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_id_;
}
inline void ServerClientMessage::_internal_set_message_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_id_ = value;
}

// string error = 2;
inline bool ServerClientMessage::has_error() const {
  return body_case() == kError;
}
inline void ServerClientMessage::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void ServerClientMessage::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kError) {
    _impl_.body_.error_.Destroy();
    clear_has_body();
  }
}
inline const std::string& ServerClientMessage::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.ServerClientMessage.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerClientMessage::set_error(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() != kError) {
    clear_body();

    set_has_error();
    _impl_.body_.error_.InitDefault();
  }
  _impl_.body_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:battle_c.ServerClientMessage.error)
}
inline std::string* ServerClientMessage::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:battle_c.ServerClientMessage.error)
  return _s;
}
inline const std::string& ServerClientMessage::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (body_case() != kError) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.body_.error_.Get();
}
inline void ServerClientMessage::_internal_set_error(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() != kError) {
    clear_body();

    set_has_error();
    _impl_.body_.error_.InitDefault();
  }
  _impl_.body_.error_.Set(value, GetArena());
}
inline std::string* ServerClientMessage::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() != kError) {
    clear_body();

    set_has_error();
    _impl_.body_.error_.InitDefault();
  }
  return _impl_.body_.error_.Mutable( GetArena());
}
inline std::string* ServerClientMessage::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:battle_c.ServerClientMessage.error)
  if (body_case() != kError) {
    return nullptr;
  }
  clear_has_body();
  return _impl_.body_.error_.Release();
}
inline void ServerClientMessage::set_allocated_error(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_body()) {
    clear_body();
  }
  if (value != nullptr) {
    set_has_error();
    _impl_.body_.error_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:battle_c.ServerClientMessage.error)
}

// .battle_c.WorldOptions world_options = 3;
inline bool ServerClientMessage::has_world_options() const {
  return body_case() == kWorldOptions;
}
inline bool ServerClientMessage::_internal_has_world_options() const {
  return body_case() == kWorldOptions;
}
inline void ServerClientMessage::set_has_world_options() {
  _impl_._oneof_case_[0] = kWorldOptions;
}
inline void ServerClientMessage::clear_world_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kWorldOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.world_options_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.world_options_);
    }
    clear_has_body();
  }
}
inline ::battle_c::WorldOptions* ServerClientMessage::release_world_options() {
  // @@protoc_insertion_point(field_release:battle_c.ServerClientMessage.world_options)
  if (body_case() == kWorldOptions) {
    clear_has_body();
    auto* temp = _impl_.body_.world_options_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.world_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::battle_c::WorldOptions& ServerClientMessage::_internal_world_options() const {
  return body_case() == kWorldOptions ? *_impl_.body_.world_options_ : reinterpret_cast<::battle_c::WorldOptions&>(::battle_c::_WorldOptions_default_instance_);
}
inline const ::battle_c::WorldOptions& ServerClientMessage::world_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.ServerClientMessage.world_options)
  return _internal_world_options();
}
inline ::battle_c::WorldOptions* ServerClientMessage::unsafe_arena_release_world_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:battle_c.ServerClientMessage.world_options)
  if (body_case() == kWorldOptions) {
    clear_has_body();
    auto* temp = _impl_.body_.world_options_;
    _impl_.body_.world_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerClientMessage::unsafe_arena_set_allocated_world_options(::battle_c::WorldOptions* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_world_options();
    _impl_.body_.world_options_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.ServerClientMessage.world_options)
}
inline ::battle_c::WorldOptions* ServerClientMessage::_internal_mutable_world_options() {
  if (body_case() != kWorldOptions) {
    clear_body();
    set_has_world_options();
    _impl_.body_.world_options_ =
        ::google::protobuf::Message::DefaultConstruct<::battle_c::WorldOptions>(GetArena());
  }
  return _impl_.body_.world_options_;
}
inline ::battle_c::WorldOptions* ServerClientMessage::mutable_world_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::battle_c::WorldOptions* _msg = _internal_mutable_world_options();
  // @@protoc_insertion_point(field_mutable:battle_c.ServerClientMessage.world_options)
  return _msg;
}

// .battle_c.PlayerData player_data = 4;
inline bool ServerClientMessage::has_player_data() const {
  return body_case() == kPlayerData;
}
inline bool ServerClientMessage::_internal_has_player_data() const {
  return body_case() == kPlayerData;
}
inline void ServerClientMessage::set_has_player_data() {
  _impl_._oneof_case_[0] = kPlayerData;
}
inline void ServerClientMessage::clear_player_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kPlayerData) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.player_data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.player_data_);
    }
    clear_has_body();
  }
}
inline ::battle_c::PlayerData* ServerClientMessage::release_player_data() {
  // @@protoc_insertion_point(field_release:battle_c.ServerClientMessage.player_data)
  if (body_case() == kPlayerData) {
    clear_has_body();
    auto* temp = _impl_.body_.player_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.player_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::battle_c::PlayerData& ServerClientMessage::_internal_player_data() const {
  return body_case() == kPlayerData ? *_impl_.body_.player_data_ : reinterpret_cast<::battle_c::PlayerData&>(::battle_c::_PlayerData_default_instance_);
}
inline const ::battle_c::PlayerData& ServerClientMessage::player_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.ServerClientMessage.player_data)
  return _internal_player_data();
}
inline ::battle_c::PlayerData* ServerClientMessage::unsafe_arena_release_player_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:battle_c.ServerClientMessage.player_data)
  if (body_case() == kPlayerData) {
    clear_has_body();
    auto* temp = _impl_.body_.player_data_;
    _impl_.body_.player_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerClientMessage::unsafe_arena_set_allocated_player_data(::battle_c::PlayerData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_player_data();
    _impl_.body_.player_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.ServerClientMessage.player_data)
}
inline ::battle_c::PlayerData* ServerClientMessage::_internal_mutable_player_data() {
  if (body_case() != kPlayerData) {
    clear_body();
    set_has_player_data();
    _impl_.body_.player_data_ =
        ::google::protobuf::Message::DefaultConstruct<::battle_c::PlayerData>(GetArena());
  }
  return _impl_.body_.player_data_;
}
inline ::battle_c::PlayerData* ServerClientMessage::mutable_player_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::battle_c::PlayerData* _msg = _internal_mutable_player_data();
  // @@protoc_insertion_point(field_mutable:battle_c.ServerClientMessage.player_data)
  return _msg;
}

// .battle_c.PlayersSighted players_sighted = 5;
inline bool ServerClientMessage::has_players_sighted() const {
  return body_case() == kPlayersSighted;
}
inline bool ServerClientMessage::_internal_has_players_sighted() const {
  return body_case() == kPlayersSighted;
}
inline void ServerClientMessage::set_has_players_sighted() {
  _impl_._oneof_case_[0] = kPlayersSighted;
}
inline void ServerClientMessage::clear_players_sighted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kPlayersSighted) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.players_sighted_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.players_sighted_);
    }
    clear_has_body();
  }
}
inline ::battle_c::PlayersSighted* ServerClientMessage::release_players_sighted() {
  // @@protoc_insertion_point(field_release:battle_c.ServerClientMessage.players_sighted)
  if (body_case() == kPlayersSighted) {
    clear_has_body();
    auto* temp = _impl_.body_.players_sighted_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.players_sighted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::battle_c::PlayersSighted& ServerClientMessage::_internal_players_sighted() const {
  return body_case() == kPlayersSighted ? *_impl_.body_.players_sighted_ : reinterpret_cast<::battle_c::PlayersSighted&>(::battle_c::_PlayersSighted_default_instance_);
}
inline const ::battle_c::PlayersSighted& ServerClientMessage::players_sighted() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.ServerClientMessage.players_sighted)
  return _internal_players_sighted();
}
inline ::battle_c::PlayersSighted* ServerClientMessage::unsafe_arena_release_players_sighted() {
  // @@protoc_insertion_point(field_unsafe_arena_release:battle_c.ServerClientMessage.players_sighted)
  if (body_case() == kPlayersSighted) {
    clear_has_body();
    auto* temp = _impl_.body_.players_sighted_;
    _impl_.body_.players_sighted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerClientMessage::unsafe_arena_set_allocated_players_sighted(::battle_c::PlayersSighted* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_players_sighted();
    _impl_.body_.players_sighted_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.ServerClientMessage.players_sighted)
}
inline ::battle_c::PlayersSighted* ServerClientMessage::_internal_mutable_players_sighted() {
  if (body_case() != kPlayersSighted) {
    clear_body();
    set_has_players_sighted();
    _impl_.body_.players_sighted_ =
        ::google::protobuf::Message::DefaultConstruct<::battle_c::PlayersSighted>(GetArena());
  }
  return _impl_.body_.players_sighted_;
}
inline ::battle_c::PlayersSighted* ServerClientMessage::mutable_players_sighted() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::battle_c::PlayersSighted* _msg = _internal_mutable_players_sighted();
  // @@protoc_insertion_point(field_mutable:battle_c.ServerClientMessage.players_sighted)
  return _msg;
}

// .battle_c.RadarResult radar_result = 6;
inline bool ServerClientMessage::has_radar_result() const {
  return body_case() == kRadarResult;
}
inline bool ServerClientMessage::_internal_has_radar_result() const {
  return body_case() == kRadarResult;
}
inline void ServerClientMessage::set_has_radar_result() {
  _impl_._oneof_case_[0] = kRadarResult;
}
inline void ServerClientMessage::clear_radar_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kRadarResult) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.radar_result_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.radar_result_);
    }
    clear_has_body();
  }
}
inline ::battle_c::RadarResult* ServerClientMessage::release_radar_result() {
  // @@protoc_insertion_point(field_release:battle_c.ServerClientMessage.radar_result)
  if (body_case() == kRadarResult) {
    clear_has_body();
    auto* temp = _impl_.body_.radar_result_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.radar_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::battle_c::RadarResult& ServerClientMessage::_internal_radar_result() const {
  return body_case() == kRadarResult ? *_impl_.body_.radar_result_ : reinterpret_cast<::battle_c::RadarResult&>(::battle_c::_RadarResult_default_instance_);
}
inline const ::battle_c::RadarResult& ServerClientMessage::radar_result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.ServerClientMessage.radar_result)
  return _internal_radar_result();
}
inline ::battle_c::RadarResult* ServerClientMessage::unsafe_arena_release_radar_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:battle_c.ServerClientMessage.radar_result)
  if (body_case() == kRadarResult) {
    clear_has_body();
    auto* temp = _impl_.body_.radar_result_;
    _impl_.body_.radar_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerClientMessage::unsafe_arena_set_allocated_radar_result(::battle_c::RadarResult* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_radar_result();
    _impl_.body_.radar_result_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.ServerClientMessage.radar_result)
}
inline ::battle_c::RadarResult* ServerClientMessage::_internal_mutable_radar_result() {
  if (body_case() != kRadarResult) {
    clear_body();
    set_has_radar_result();
    _impl_.body_.radar_result_ =
        ::google::protobuf::Message::DefaultConstruct<::battle_c::RadarResult>(GetArena());
  }
  return _impl_.body_.radar_result_;
}
inline ::battle_c::RadarResult* ServerClientMessage::mutable_radar_result() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::battle_c::RadarResult* _msg = _internal_mutable_radar_result();
  // @@protoc_insertion_point(field_mutable:battle_c.ServerClientMessage.radar_result)
  return _msg;
}

// .battle_c.ShootResult shoot_result = 7;
inline bool ServerClientMessage::has_shoot_result() const {
  return body_case() == kShootResult;
}
inline bool ServerClientMessage::_internal_has_shoot_result() const {
  return body_case() == kShootResult;
}
inline void ServerClientMessage::set_has_shoot_result() {
  _impl_._oneof_case_[0] = kShootResult;
}
inline void ServerClientMessage::clear_shoot_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kShootResult) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.shoot_result_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.shoot_result_);
    }
    clear_has_body();
  }
}
inline ::battle_c::ShootResult* ServerClientMessage::release_shoot_result() {
  // @@protoc_insertion_point(field_release:battle_c.ServerClientMessage.shoot_result)
  if (body_case() == kShootResult) {
    clear_has_body();
    auto* temp = _impl_.body_.shoot_result_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.shoot_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::battle_c::ShootResult& ServerClientMessage::_internal_shoot_result() const {
  return body_case() == kShootResult ? *_impl_.body_.shoot_result_ : reinterpret_cast<::battle_c::ShootResult&>(::battle_c::_ShootResult_default_instance_);
}
inline const ::battle_c::ShootResult& ServerClientMessage::shoot_result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:battle_c.ServerClientMessage.shoot_result)
  return _internal_shoot_result();
}
inline ::battle_c::ShootResult* ServerClientMessage::unsafe_arena_release_shoot_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:battle_c.ServerClientMessage.shoot_result)
  if (body_case() == kShootResult) {
    clear_has_body();
    auto* temp = _impl_.body_.shoot_result_;
    _impl_.body_.shoot_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerClientMessage::unsafe_arena_set_allocated_shoot_result(::battle_c::ShootResult* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_shoot_result();
    _impl_.body_.shoot_result_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:battle_c.ServerClientMessage.shoot_result)
}
inline ::battle_c::ShootResult* ServerClientMessage::_internal_mutable_shoot_result() {
  if (body_case() != kShootResult) {
    clear_body();
    set_has_shoot_result();
    _impl_.body_.shoot_result_ =
        ::google::protobuf::Message::DefaultConstruct<::battle_c::ShootResult>(GetArena());
  }
  return _impl_.body_.shoot_result_;
}
inline ::battle_c::ShootResult* ServerClientMessage::mutable_shoot_result() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::battle_c::ShootResult* _msg = _internal_mutable_shoot_result();
  // @@protoc_insertion_point(field_mutable:battle_c.ServerClientMessage.shoot_result)
  return _msg;
}

inline bool ServerClientMessage::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void ServerClientMessage::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline ServerClientMessage::BodyCase ServerClientMessage::body_case() const {
  return ServerClientMessage::BodyCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace battle_c


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::battle_c::RadarReturnType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::battle_c::RadarReturnType>() {
  return ::battle_c::RadarReturnType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // battle_5fc_2eproto_2epb_2eh
